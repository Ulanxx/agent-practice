# PPTGen 到 AnyGenAgent：全场景智能生成系统全量方案文档

## 1. 项目背景与方案演进结论

### 1.1 方案对比与技术定型
在项目初期，我们针对 PPT 生成探索了两种核心路径，最终确定了以 **XML 结构化驱动** 为核心的工业级方案：

| 维度 | HTML 直转 (Playwright) | XML 结构化驱动 (DSL) |
| :--- | :--- | :--- |
| **还原度** | 视觉 100% 还原，但属性难以映射 | 属性对齐 100%，结构严谨 |
| **可编辑性** | 极低（通常为截图或死板对象） | **极高**（组件化模型，支持增量编辑） |
| **LLM 友好度** | 复杂 CSS 容易导致 LLM 输出幻觉 | **友好**（固定 Schema，逻辑确定） |
| **结论** | 仅适合作为复杂图形的辅助补充 | **核心方案：作为中间表达层 (IR)** |

---

## 2. 核心架构：Agentic 工作流设计

为了解决 LLM 生成的随机性，系统引入了 **Agentic Loop**，将生成过程拆解为可干预、可观测的多个阶段。

### 2.1 任务生命周期
1.  **需求对齐 (Consulting)**：通过 AI 动态表单补全模糊需求。
2.  **过程思考 (CoT)**：实时展示 Agent 的逻辑推导，增强用户信任。
3.  **资产筹备 (Asset Matching)**：物料库语义化匹配（图片、图标、配色）。
4.  **结构生成 (DSL Generation)**：产出标准的中间表达 XML。
5.  **渲染输出 (Rendering)**：调用物理引擎产出最终文件。

### 2.2 交互设计亮点
*   **中间结果预览**：在大纲和物料阶段提供草图预览。
*   **增量迭代修改**：用户通过自然语言反馈，Agent 仅修改 XML 中特定节点的属性，实现精准微调。

---

## 3. Server 端方案：基于 NestJS 的工业级实现

后端采用 NestJS 框架，利用其强类型和模块化特性支持从 PPTGen 到 AnyGen 的快速扩展。

### 3.1 核心模块架构
*   **AgentModule**：逻辑编排中心，负责 CoT 和状态机流转。
*   **RenderModule**：插件化渲染引擎，支持通过 Adapter 扩展不同格式（PPT/Web/PDF）。
*   **AssetModule (Omni-Asset Hub)**：统一的多模态物料中心，支持跨场景物料共享。
*   **SocketModule**：基于 **WebSocket** 的实时双向通信。

### 3.2 为什么选择 WebSocket 而非 SSE？
1.  **双向性**：支持用户在生成过程中随时进行干预和中断。
2.  **复杂交互**：更适合处理状态机切换和复杂的 JSON 对象传输。
3.  **协同编辑**：为后续支持多端同步和冲突解决奠定基础。

---

## 4. 扩展性设计：走向 AnyGenAgent

为了支持快速扩展到网页生成、报告编写、视频脚本等场景，系统采用了**插件化与协议化**的设计。

### 4.1 通用 Agent 基类
定义了感知、思考、工具调用的基类，所有领域 Agent（如 WebGenAgent）通过继承和实现特定的渲染适配器即可快速上线。

### 4.2 统一中间件语义 (Omni-IR)
建立一套通用的 DSL 协议，解耦内容生成与物理渲染。一套语义，多端映射。

---

## 5. 行业参考
*   **Canva / Microsoft 365 Copilot**：均采用了类似的“语义理解 -> 结构化数据 -> 组件化渲染”路径。
*   **Gamma.app**：验证了 DSL 驱动+实时预览方案在现代 AI 产品中的巨大商业潜力。

---

## 6. 路线图 (Master Roadmap)
1.  **Phase 1**: 解耦当前 PPT 渲染逻辑为独立插件。
2.  **Phase 2**: 建立统一的 Asset Hub 资产中心。
3.  **Phase 3**: 完善 NestJS 后端状态机与 WebSocket 协议。
4.  **Phase 4**: 快速接入第二个生成场景（如 Web 或 Markdown 报告）。
